\section{Metoda zagnieżdzonych zbiorów}
\index{metoda!zagnieżdzonych zbiorów|(textbf}

Metoda została spopularyzowana przez Joe Celko\cite{celko-sql}\index{Celko Joe}.






\temat{Reprezentacja}

\begin{verbatim}[table] nested
>n1 _
id | lft | rgt | name
1  | 1   | 20  | Bazy Danych

>n2 n1
id | lft | rgt | name
2  | 2   | 5   | Obiektowe

>n3 n2
id | lft | rgt | name
3  | 3   | 4   | db4o

>n4 n1
id | lft | rgt | name
4  | 6   | 17  | Relacyjne

>n5 n4
id | lft | rgt | name
5  | 7   | 14  | Open Source

>n7 n5
id | lft | rgt | name
6  | 8   | 9   | PostgreSQL

>n8 n5
id | lft | rgt | name
7  | 10  | 11  | MySQL

>n9 n5
id | lft | rgt | name
8  | 12  | 13  | SQLite

>n6 n4
id | lft | rgt | name
9  | 15  | 16  | Komercyjne

>n10 n1
id | lft | rgt | name
10 | 18  | 19  | XML

\end{verbatim}

\temat{Operacje}

\operacja{Reprezentacja w SQL}
%! method-sql nested.create

\operacja{Wstawianie danych}
%! method-python nested.insert



% \begin{verbatim}[sql]
% INSERT INTO simple (parent, name) VALUES (:parent, :name)
% \end{verbatim}

Wstawianie danych w tej metodzie jest jej najsłabszą stroną.
\todo{terminologia}
Wymaga ono zmiany wartości lft i rgt wielu rekordów.

W powyższym przypadku
--- jako że wstawiamy dane w kolejności \emph{in depth} ---
wymagana jest modyfikacja tylko tylu rekordów na jakim poziomie\todo{?} aktualnie wstawiamy nowy węzeł.
Lecz należy sie liczyć z przypadkiem pesymistycznym --- dodaniem do korzenia potomka jako pierwszego elementu\todo{las}.
W takiej sytuacji wymagane jest zmodyfikowanie wszystkich istniejących rekordów.

\textbf{Uwaga:} Jeśli chce się jednorazowo załadować cały las do bazy danych można postąpić bardziej optymalnie\footnote{
    Powyższy kod tego nie robi gdyż ma być ogólny.
}.
Mianowicie przed załadowaniem danych do bazy danych wstępnie przetworzyć dane.
W takiej sytuacji należy sie posłużyć algorytmem \emph{wyszukiwania w głąb}
i~kolejno numerować wartości \texttt{lft} węzła po wejściu do niego oraz \texttt{rgt} przed jego opuszczeniem.
Przykładowa implementacja tego algorytmu:

\begin{verbatim}[sql]
def preprocess(node):
  node.lft = get_next_int()
  for n in children(node):
    preprocess(n)
  node.rgt = get_next_int()
\end{verbatim}

\operacja{Pobranie korzeni}
%! method-python nested.roots

\operacja{Pobranie rodzica}
%! method-sql nested.parent

\operacja{Pobranie dzieci}
%! method-sql nested.children

\operacja{Pobranie przodków}
%! method-sql nested.ancestors

\operacja{Pobieranie potomków}
%! method-sql nested.descendants


\subsection{Uwagi}

Metoda umożliwia bardzo proste pobieranie liści drzewa. 
Jest ono możliwe dzięki temu, że $a.right - a.left = 2 * |a.descendants()| + 1$. 
Skoro liść nie posiada żadnych potomków to da różnica wynosi $1$, co prowadzi do zapytania: 
\begin{verbatim}[sql]
SELECT *
  FROM nested_sets
  WHERE lft + 1 = rgt
\end{verbatim}


\temat{Wydajność}

\begin{qxtab}{nested}{Wydajność reprezentacji zagnieżdzonych zbiorów}
%! result-table nested deep3
\end{qxtab}

\begin{qxfig}{nested}{Wydajność reprezentacji zagnieżdzonych zbiorów}
%! result-chart nested deep3
\end{qxfig}

\index{metoda!zagnieżdzonych zbiorów|)}
