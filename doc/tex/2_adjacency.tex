\section{Metoda krawędziowa}
\index{metoda!krawędziowa|(textbf}


% Hierarchies like trees, organizational charts, ... are sometimes difficult to
% store in database tables. The most common database pattern to store 
% hierachical data is known as the adjacency model. It has been introduced 
% by the famous computer scientist Edgar Frank Codd. It's called the "adjacency"
% model because a reference to the parent data is stored in the same row as the
% child data, in an adjacent column. These kind of tables are also called self 
% referencing tables.
% http://www.scip.be/index.php?Page=ArticlesNET18


% It was Scott's pet cat called "tiger".
% And, who was Scott? His first name was Scott but Bruce. Bruce Scott was
% employee number #4 at the then Software Development Laboratories that
% eventually became Oracle. He co-authored and co-architected Oracle V1, V2 & V3.
% http://www.dba-oracle.com/t_scott_tiger.htm

% http://pl.wikipedia.org/wiki/Reprezentacja_grafu#Reprezentacja_przez_listy_s.C4.85siedztwa



Najprostszą, najbardziej intuicyjną i zapewne najpopularniejszą metodą jest metoda krawędziowa \eng{adjacency}\index{adjacency}.
Została ona spopularyzowana przez Edgara Franka Codda\index{Codd Edgar Frank}. 
%On też nadał im nazwę, która odnosi się do tego, że informacja o rodzicu elementu znajduje się w tej samej krotce\todo{krotka?} co dane.
Nadał też jej nazwę. Wynika ona z tego, że każdy rekord zawiera własny identyfikator oraz identyfikator rodzica. Takie dane są wystarczające aby w drzewie opisać krawędz.


Zasługa spopularyzowania tej metody przypada Oracle.
Dołączył on do swojego produktu przykładową bazę danych, nazywaną ,,Scott/Tiger'' 
korzystającą z tej metody.
\footnote{
    Nazwa tej bazy danych pochodzi od metody autoryzacji w bazie Oracle (login/hasło).
    Login pochodził z nazwiska jednego z pierwszych pracowników 
    Software Development Laboratories (przekształconych ostatecznie w Oracle) Bruce'a Scott'a. 
    Natomiast hasło to imię jego kota.
}

Na popularność metody przekłada się również jej znaczące podobieństwo do 
używanego między innymi w~językach C i~C++ sposobu przechowywania list i drzew.
Mianowicie każdy węzeł zawiera wskaźnik na rodzica. 
W relacyjnych bazach danych odpowiednikiem wskaźnika jest klucz obcy\index{klucz!obcy}. 


Ta metoda jest na tyle popularna, że w bazach danych pojawiły się specjalne konstrukcje do jej obsługi. 
Zostaną one przedstawione w rozdziale \todo{wstawić jakoś nazwę rozdziału} o metodach specyficznych dla systemu zarządzania bazą danych.


\temat{Reprezentacja}

\begin{verbatim}[table] adjacency
>n1 _
id | parent | name
1  | NULL   | Bazy Danych

>n2 n1
id | parent | name
2  | 1      | Obiektowe

>n3 n2
id | parent | name
3  | 2      | db4o

>n4 n1
id | parent | name
4  | 1      | Relacyjne

>n5 n4
id | parent | name
5  | 4      | Open Source

>n7 n5
id | parent | name
6  | 5      | PostgreSQL

>n8 n5
id | parent | name
7  | 5      | MySQL

>n9 n5
id | parent | name
8  | 5      | SQLite

>n6 n4
id | parent | name
9  | 4      | Komercyjne

>n10 n1
id | parent | name
10 | 1      | XML

\end{verbatim}


\operacja{Reprezentacja w SQL}
\vspace{-0.5cm}
%! method-sql simple.create

\vspace{-0.5cm}

Należy zwrócić uwagę na \todo{term}warunek \texttt{ON DELETE CASCADE}. 
Sprawia on, że w razie usunięcia węzła \todo{ustalić terminologię} 
automatycznie zostaną usunięci wszyscy jego potomkowie.


\operacja{Wstawianie danych}
%! method-sql simple.insert

\operacja{Pobranie korzeni}
Cechą charakterystyczną korzenia jest to, że jego rodzic jest ustawiony na \texttt{NULL}. Więc wybranie rodziców sprowadza się do tego zapytania:
%! method-sql simple.roots

\operacja{Pobranie rodzica}
\todo{a może by zrobić to złączeniem?}
%! method-sql simple.parent

\operacja{Pobranie dzieci}
%! method-sql simple.children

\operacja{Pobranie przodków}
%! method-sql simple.ancestors

\operacja{Pobieranie potomków}
%! method-sql simple.descendants

Należy zwrócić uwagę na wykorzystanie operatora \texttt{IN}. Bez niego wydajność metody spada znacząco. 

\temat{Wydajność}

\begin{qxtab}{simple}{Wydajność reprezentacji krawędziowej}
%! result-table simple deep3
\end{qxtab}

\begin{qxfig}{simple}{Wydajność reprezentacji krawędziowej}
%! result-chart simple deep3
\end{qxfig}

\index{metoda!krawędziowa|)}
