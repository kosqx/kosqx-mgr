\chapter{Metodyka testów wydajności}

Ważnyme elementem tej pracy jest sprawdzenie wydajności przedstawionych metod w bazach danych.
Zostaną tu przedstawione warunki w jakich odbywały się testy.

\section*{Wybrane SZDB}

Do testów zostały wybrane popularne, dostępne bezpłatnie (również do zastosowań komercyjnych) bazy danych. 
%W przypadku baz Open Source wykorzystano najnowsze, stabilne wersje.
Dla baz komercyjnych zostały wybrane ich darmowe edycje. 
Posiadają one ograniczenia co do wielkości baz danych, wykorzystania zasobów oraz zmniejszoną funkcjonalność. 
Specyfika testów sprawia jednak, że te ograniczenia nie miały znaczenia podczas testów.




% \begin{itemize}
%  \item PostgreSQL\index{PostgreSQL}
%  \item MySQL\index{MySQL}
%  \item SQLite\index{SQLite}
%  \item Oracle Database 10g Express Edition\index{Oracle}
%  \item IBM DB2 Express-C\index{IBM DB2}
%  \item Microsoft SQL Server 2008 Express\index{SQL Server}
% \end{itemize}

\begin{qxtab}{edgeenum}{Użyte wersje baz danych}
\begin{tabular}{l|l|l}
Baza danych                            & Wersja & Edycja \\
\hline
PostgreSQL\index{PostgreSQL}           &  8.4      & \\
MySQL\index{MySQL}                     &  5.1      & \\
SQLite\index{SQLite}                   &  3        & \\
Oracle Database\index{Oracle}          &  10g      & Express Edition \\
IBM DB2\index{IBM DB2}                 &  9.7      & Express-C \\
Microsoft SQL Server\index{SQL Server} &  2008 R2  & Express\\
\end{tabular}
\end{qxtab}

\todo{Napisać jaki typ tabelek został użyty w MySQL (MyISAM, InnoDB)}

% Wybrane zostały SZDB spełniające następujące cechy:
% \begin{itemize}
%  \item popularne
%  \item darmowe do użytku domowego 
% \end{itemize}


% Dla porównania innych rozwiązań zostały dobrane następujące bazy danych:
% 
% \begin{itemize}
%  \item db4o
%  \item berkeley DB
%  \item ??
% \end{itemize}



\section*{Dane testowe}

By móc porównać metody przechowywania danych hierarchicznych należy zapewnić jednorodne warunki testów.
Oznacza to konieczność wykonywania dokładnie tych samych operacji z takimi samymi parametrami w tej samej kolejności.
Aby to osiągnąć testy są przechowywane jako pliki XML (w podkatalogu \verb|src/data|).

%W tym celu zastosowano pliki 

Dane użyte podczas testów zostały wygenerowane w sposób automatyczny.
Opisują one las o wysokości $10$, zawierający dwa drzewa, 
z każdym węzłem wewnętrznym o stopniu $2$.
W efekcie całe drzewo ma $4094$ węzłów.



%Program który zajmuje się tym zadaniem został dołączony do tej pracy.
%
%Dane użyte podczas testów pochodzą to drzewo kategorii \url{http://www.dmoz.org/}.
%
%
%%\begin{qxtab}{dmozdist}{Liczebność węzłów na poszczegółnych poziomach w danych testowych}\end{qxfig}
%\begin{tabular}{|l|l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }l@{ }|}
%\hline
%Poziom     & 0      & 1     & 2     & 3     & 4     & 5     & 6     & 7     & 8     & 9     & 10    & 11 \\
%\hline
%Liczebność & 21     & 539   & 6259  & 25834 & 50654 & 41752 & 31325 & 21573 & 7388  & 2090  & 303   & 16 \\
%\hline
%\end{tabular}
%%\end{qxtab}
%
%
%Większość testów wymaga identyfikatorów węzłów. 
%Wybranie losowego identyfikatora z istniejących w bazie danych było by najprostrzym 
%ale też niedoskonałym \todo{obarczonym błędem} rozwiązaniem.
%Wynika to z tego, że w drzewe (o stopniu większym niż 2\todo{bardzo nieprecyzyjnie napisane}) 
%liście stanowią najliczniejszą grupę węzłów.
%Natomiast węzły o niskim poziomie są małoliczne.
%Dlatego zapytanie o potomków tak wylosowanego węzła było by zadaniem prostym, natomiast przodków --- trudnym (gdyż z dużym prawdopodobieństwem wylosowany by został liść).
%
%Aby zapobiec takiej sytuacji identyfikatory dla zapytań losowane są dwuetapowo:
%\begin{enumerate}
% \item najpierw losowany jest jeden z poziomów węzłów w drzewie
% \item nastepnia losowany jest jeden z węzłów identyfikatorów
%\end{enumerate}
%Ta procedura powtarza się do uzyskania wymaganej ilości identyfikatorów węzłów. 
%W obu losowaniach wykorzystywany jest \emph{dyskretny rozkład jednostajny}. 




% Aby przetestować przedstawione rozwiązania wykożystane zostały następujące zestawy danych:
% \begin{itemize}
%  \item mały test 100 dwupoziomowo
%  \item test mocnego zagłębienia
%  \item test małego zagłebienia
%  \item test 6 pozimów po 3 zagłębienia 
% \end{itemize}


% Parametry generatora danych:
% \begin{itemize}
%  \item minimalny poziom zagłębienia
%  \item maksymalny poziom zagłębienia
%  \item rozklad prawdopodobieństwa wygenerowania dzieci (\cite{asdf}, \cite[Ala]{asdf})
% \end{itemize}


\section*{Środowisko testowe}

Bazy danych były testowane na systemie operacyjnym \emph{Microsoft Windows 7 32bit}.
Wybór ten był podyktowany faktem, że jedna z testowanych baz (SQL Server) posiadała wersję wyłącznie na systemy z rodziny Windows.

Sprzęt, na którym wykonywane były testy, składał się z:
\begin{itemize}
  \item procesora Intel Core2 Quad 2.4 Ghz
  \item 4 GB pamięci DDR2 (3,25 GB pamięci dostępnej dla systemu)
  \item dysku HDD 1TB klasy ekonomicznej
\end{itemize}

Server bazy danych działał na tej samej maszynie co program testujący.
Zminejszało to opóźnienia sieciowe ale zwiększało zużycie procesora%
\footnote{W praktyce na maszynie czterordzeniowej czas procesora nie był problemem.}.

%Aby zminimalizować potencjalne problemy wynikające z instalacji wielu baz na 
%jednej maszynie dla potrzeb testów zostały stworzone dla nich odzielne maszyny wirtualne. 
%Wykorzystano VirtualBox 2.1. Każdej maszynie został przyznany 10GB virtualny dysk 
%o~stałym rozmiarze oraz 512 MB RAM. Program testujący działał również na maszynie wirtualnej, 
%więc ominięto problem przepustowości interfacu sieciowego. 
%\todo{lepsze nazwy; wersja; usunac powtórzenia}
%
%Bazy posiadające wersję dla systemu GNU/Linux zostały zainstalowane na nim. 
%Baza Microsoft SQL Server została zainstalowana na Windows XP Service Pack 2.

\section*{Optymalizacje}

%Najczęstrzym zastrzerzeniem odnoszącym się do wyników benchmarków
%
%

Aby nie faworyzować żadnej z testowanych baz ustanowione zostały poniższe zasady:
\begin{itemize}
    \item Bazy nie były w żaden sposób dostrajane \eng{database tuning}, czyli pracują z domyślnymi ustawieniami.
    \item Nie zastosowano indeksów\footnote{Jawnych indeksów --- klucze główne były stosowane}
        oraz kluczy obcych.
  %\item Algorytm każdej operacji był pisane tak by był czytelne i ogólne, a nie
    Zapytania były pisane z myślą by być czytelne i dobrze ilustrować koncepcje danej reprezentacji.
    Została więc zastowowana maksyma Donalda Knutha: \emph{,,przedwczesna optymalizacja jest źródłem wszelkiego zła''}.
\end{itemize}

\section*{Prezentacja wyników}

Wyniki wydajności są prezentowane na końcu opisu każdej z opisywanych metod.
Są podawane zarówno w postaći tabeli (umożliwiającej dokładną analizę wyników)
jak i wykresu słupkowego (dającego możliwość szybkiego przejżenia wyników).

%%Uwagi:
%% - 
%%
%%Prezentacja wyników: jako przepustowość (czyli większa wartość - lepiej)

Zastosowaną miarą wydajności jest \emph{przepustowość} (czyli ilość wykonanych zapytań w danym czasie).
Takie podejście jest intuicyjne dla ludzi --- większa wartość oznacza lepszy wynik. 
