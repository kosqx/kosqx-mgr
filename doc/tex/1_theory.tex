\chapter{Wprowadzenie do tematu}


% The hierarchical data model organizes data in a tree structure. There is a hierarchy of parent and child data segments

\section{Podstawowe definicje}

Drzewa można traktować i definiować na wiele równoważnych sposobów.
Przykładowo w~teorii grafów jest to acykliczny i spójny graf.
W informatyce częściej stosuje się definicję rekurencyjną.
Wynika to z częstego w informatyce wymogu by drzewo było uporządkowane.
Taki twór formalnie nie jest grafem.


Poniżej zostaną przedstawione najważniejsze, używane w tej pracy definicje (na podstawie \cite{knuth}).


\treedef{Drzewo} \eng{tree} definiujemy jako zbiór $T$ zawierający jeden lub więcej elementów $t \in T$ zwanych \treedef{węzłami} \eng{node}, takich że:

\begin{enumerate}
 \item
    istnieje jeden wyróżniony węzeł zwany \treedef{korzeniem} drzewa, $root(T)$
 \item
    pozostałe węzły (z wyłączeniem korzenia) są podzielone na $m \geq 0$ rozłącznych zbiorów $T_{1},\ldots, T_{m}$,
	będących drzewami. Są one nazywane \treedef{poddrzewami} \eng{subtree} korzenia.
\end{enumerate}

Każdy węzeł drzewa jest korzeniem pewnego poddrzewa zawartego w większym drzewie.
Ilość poddrzew węzła jest nazywana \treedef{stopniem} \eng{degree} tego węzła.
Węzeł o~stopniu zero nazywamy \treedef{liściem} \eng{leaf} lub \treedef{węzłem zewnętrznym} \eng{terminal node}. 
Węzeł nie będący liściem nazywamy \treedef{węzłem wewnętrznym} \eng{branch node}.

% TODO: ścieżka, przodek, potomek


\treedef{Przodkami} \eng{descendant} węzła  nazywamy korzenie wszystkich drzew, w których się zawiera.
\treedef{Potomkami} \eng{ancestor} węzła  nazywamy wszystkie węzły należące do poddrzewa, którego jest korzeniem. 
Wynika z tego, że każdy węzeł jest jednocześnie swym przodkiem i potomkiem.
Jeśli węzeł $x$ jest przodkiem $y$ oraz $x \neq y$ to $x$ jest \treedef{przodkiem właściwym}.
Analogiczna, jeśli węzeł $x$ jest potomkiem $y$ oraz $x \neq y$ to $x$ jest \treedef{potomkiem właściwym}.

Korzenie poddrzew $T_{1},\ldots, T_{m}$ nawywamy \treedef{dziećmi} \eng{children} węzła.
Węzeł jest \treedef{rodzicem} \eng{parent} węzłów jeśli są one jego dziećmi.


% Karzdy węzeł jest jednocześnie swym przodkiem i potomkiem

\treedef{Poziom} \eng{level} węzła jest zdefiniowany rekurencyjnie: poziom korzenia $root(T)$ równa się zero,
a poziom każdego innego węzła jest o jeden większy niż poziom korzenia w najmniejszym 
\todo{w sensie ilości węzłów} zawierającym go poddrzewie.
Maksymalny poziom wszystkich węzłów nazywa się \treedef{wysokością} \eng{height} drzewa.
%
% TODO: wysokość
%







Jeśli względny porządek poddrzew $T_{1},\ldots, T_{m}$ w części (2) definicji jest istotny,
to mówimy, że drzewo jest \treedef{uporządkowane} \eng{ordered tree}. \todo{...}
Jeśli nie chcemy rozróżniać drzew, które różnią się jedynie kolejnością poddrzew, mówimy o drzewach \treedef{zorientowanych}.

\treedef{Lasem} \eng{forest} nazywamy zbiór zera lub więcej rozłącznych drzew. 
%Innym sposobem wyprowadzenia części (2) definicji jest stwierdzenie: \textit{węzły drzewa z wyłączeniem korzenia tworzą las}.
Abstrakcyjnie drzewa i lasy różnią się nieznacznie.
Usuwając korzeń drzewa, otrzymamy las.
Jeśli zaś wszystkie drzewa w lesie uczynimy poddrzewami jednego dodatkowego węzła, to otrzymamy drzewo.
Z tego powodu przy nieformalnym omawianiu struktur danych słowa ,,drzewa'' i ,,lasy'' są używane niemal wymiennie.


%\begin{quote}
%
%\emph{Drzewo} zdefiniujemy formalnie jako zbiór $T$ jednego lub więcej elementów zwanych \emph{węzłami}, takich że:
%
%\begin{enumerate}
% \item istnieje jeden wyróżniony węzeł zwany \emph{korzeniem} drzewa, $root(T)$; oraz
% \item pozostałe węzły (z wyłączeniem korzenia) są podzielone na $m \geq 0$ rozłącznych zbiorów $T_{1},\ldots, T_{m}$,
%	z których każdy jest drzewem. Drzewa $T_{1},\ldots, T_{m}$ nazywane są \emph{poddrzewami} korzenia.
%\end{enumerate}
%
%Z naszej definicji wynika, że każdy węzeł drzewa jest korzeniem pewnego poddrzewa zawartego w większym drzewie.
%Liczna poddrzew węzła jest nazywana stopniem tego węzła.
%Węzeł o stopniu zero nazywamy \emph{liściem} lub \emph{węzłem zewnętrznym}. 
%Węzeł nie będący liściem nazywamy \emph{węzłem wewnętrznym}. 
%Poziom węzła jest zdefiniowany rekurencyjnie: poziom korzenia $root(T)$ równa się zero,
%a poziom każdego innego węzła jest o jeden wiekszy niż poziom korzenia w najmniejszym 
%\todo{w sensie ilości węzłów} zawierającym go poddrzewie.
%
%
%
%Jeśli względny porządek poddrzew $T_{1},\ldots, T_{m}$ w części (2) definicji jest istotny,
%to mówimy, że drzewo jest \emph{uporządkowane}. \todo{...}
%Jeśli nie chcemy rozróżniać drzew, które różnią się jedynie kolejnością poddrzew, mówimy o drzewach \emph{zorientowanych}.
%
%\emph{Lasem} nazywamy zbiór zera lub więcej rozłącznych drzew. 
%Innym sposobem wyprowadzenia części (2) definicji jest stwierdzenie: \textit{węzły drzewa z wyłączeniem korzenia tworzą las}.
%
%Abstrakcyjnie drzewa i lasy niewiele się różnią.
%Jeśli usuniemy korzeń drzewa, otrzymamy las.
%W drugą stronę, jeśli wszystkie drzewa w lesie uczynimy poddrzewami jednego dodatkowego węzła, to otrzymamy drzewo.
%Z tego powodu słowa ,,drzewa'' i ,,lasy'' są przy nieformalnym omawianiu struktur danych używane niemal wymiennie.
%
%\end{quote}

%
%
%\section{Czym jest drzewo}
%\index{drzewo|textbf}
%Drzewo to bardzo powszechnie używane w informatyce pojęcie. W zależności od zastosowania może być różnie zdefiniowane.
%
%\paragraph{Drzewo jako graf}
%\index{graf}
%\paragraph{Drzewo jako struktura rekurencyjna}
%\index{rekurencja}
%
%




\section{Przyjęte założenia}

\todo{więcej wypisać, zastanowić się co z tym zrobić}

\paragraph{Terminologia angielska}
Literatura dotycząca informatyki jest zdominowana przez publikacje w języku angielskim.
Aby ułatwić czytelnikowi korzystanie z tych źródeł wiedzy przy każdym ważnym lub nietrywialnym w tłumaczeniu terminie została podana jego angielska wersja.

%\paragraph{Las}
%Przechowujemy 
% Zgodnie z definicją z poprzedniego rozdziału las jest bardzo podobny do drzewa.
%Jeśli nie potrzebny jest las a drzewo to wystarczy zauważyć,
%że chodzi nam o las składający się z tylko jednego drzewa.\todo{przepisać}


\paragraph{Drzewa uporządkowane}
Nie wymagane jest by metoda odpowiadała za przechowywanie porządku poddrzew.
Jeśli zaistnieje taki wymóg to można dodać kolumnę przeznaczoną do przechowywania wartości odpowiedzialnej za relację porządku.
Czasem istnieje też możliwość sortowania po istniejących już kolumnach, przykładowo nazwie kategorii.


\paragraph{Tabela zawiera tylko jedną kolumnę z danymi użytkownika} 
Bez problemu można dodać więcej kolumn do tabeli.
Obecność wyłącznie kolumny \texttt{name} zwiększa czytelność przykładów.


\paragraph{Przyjęty interface}

Aby móc porównywać różne metody przechowywania danych hierarchicznych należy stworzyć każdej te same warunki.
Dla tego został ustalony poniższy interface.

\begin{itemize}
    \item \textbf{\texttt{create\_table()}}
        Tworzy w bazie danych wymagane struktury.
        Zwykle sprowadza się to do wykonania sekwencji zapytań SQL z podzbioru \emph{definicji danych} \eng{DDL --- Data Definition Language}.
        Każda tabela kolumnę identyfikatora o nazwie \texttt{id}. 
        % Jest to numeryczny klucz główny \eng{primary key},
        Jest to numeryczny klucz główny,
        którego wartości są automatycznie pobierane z~sekwencji.
        Jest ona bardzo ważny gdyż wszystkie metody interface odwołują się do węzłów za jego pomocą
    \item \textbf{\texttt{insert(parent, name)}}
    	Dodaje nowy węzeł o wartości \texttt{name} jako potomka węzła o~identyfikatorze \texttt{parent}.
    	Zwraca identyfikator nowo wstawionego rekordu.
    \item \textbf{\texttt{get\_roots()}}
    	Zwraca rekordy  \emph{korzeni} wszystkich drzew w lesie.
    \item \textbf{\texttt{get\_parent(id)}}
    	Zwraca rekord \emph{rodzica} węzła, którego identyfikator został podany jako parametr.
    \item \textbf{\texttt{get\_ancestors(id)}}
    	Zwraca listę rekordów  \emph{przodków} węzła, którego identyfikator został podany jako parametr.
    	Lista jest posortowana malejąco wedle poziomu rekordu, czyli korzeń jest jej ostatnim elementem.
        %W praktyce bardzo często potrzebna jest lista zawierająca nie tylko przodków danego węzła ale również jego samego.
        %Więc ta metoda 
    \item \textbf{\texttt{get\_children(id)}}
    	Zwraca listę rekordów \emph{dzieci} węzła, którego identyfikator został podany jako parametr.
    \item \textbf{\texttt{get\_descendants(id)}}
    	Zwraca listę rekordów \emph{właściwych potomków} węzła, którego identyfikator został podany jako parametr.
    	Metoda nie wymaga konkretnej kolejności --- jest ona zależna od zastosowanego algorytmu.
    	W praktyce najczęściej jest to kolejność specyficzna dla przeszukiwania wszerz
\end{itemize}

Jak widać są to operacje wyłącznie związane z hierarchiczną strukturą danych.

%\begin{itemize*}
%    \item \treedef{Pobranie korzeni}
%    \item \treedef{Pobranie rodzica}
%    \item \treedef{Pobranie przodków}
%        \textbf{Uwaga:} W praktyce bardzo często potrzebna jest lista zawierająca nie tylko przodków danego węzła
%        ale również jego samego.
%        % W efekcie 
%    \item \treedef{Pobranie dzieci}
%    \item \treedef{Pobranie potomków}
%\end{itemize*}




\paragraph{Przedstawione fragmenty kodu} 
W opisach metod znajdują się fragmenty kodu SQL implementujące operacje na nich. 
Tam gdzie to jest możliwe (czyli metoda jest dostępna ) została zaprezentowana składnia PostgreSQL\index{PostgreSQL}.
Jeśli operacja potrzebuje danych wejściowych zostają one podane jako nazwa parametru poprzedzona dwukropkiem --- przykładowo \texttt{:id}.

% Takie format w Pythonie jest obsługiwany przez .
% Natomiast w Javie za pomocą klasy \texttt{NamedParameterStatement}.

%Fragmenty kodu \todo{napisać o tym że gdzieniegdzie pojawiają się \texttt{:name}} wymagające parametrów...

Część operacji nie daje się wykonać wyłącznie za pomocą jednego (lub więcej) zapytań SQL.
W takiej sytuacji fragmenty kodu zawierają kod języka \emph{Python}\index{Python}.
Został on wybrany do tego zadania ze względu na jego ekspresyjność, zwięzłość oraz wysoki poziom abstrakcji.
Z powodu tych cech jest często nazywany \emph{wykonywalnym pseudokodem}.

%Aby polepszyć zwięzłość fragmenty kodu korzystają z biblioteki PADA, stworzonej aby uprościć pisanie implementacji opisanych metod. 
%Więcej informacji o tej bibliotece znajduje się w dodatkach\todo{Załączniku 2}.



%\paragraph{Operacje z wykorzystaniem \texttt{id}}
%Wszystkie operacje wykorzystują sztucznie utworzony klucz główny\index{klucz!główny} \texttt{id}. 




\section{Metodyka testów}

Ważnym elementem tej pracy jest sprawdzenie wydajności przedstawionych metod w bazach danych.
W tym rozdziale zostaną przedstawione warunki w jakich odbywały się testy.

\subsection*{Wybrane SZDB}

Do testów zostały wybrane popularne, dostępne bezpłatnie bazy danych. 
%W przypadku baz Open Source wykorzystano najnowsze, stabilne wersje.
Dla baz komercyjnych zostały wybrane ich darmowe edycje. 
Posiadają one ograniczenia co do wielkości danych, wykorzystania zasobów oraz zmniejszoną funkcjonalność. 
Specyfika testów sprawia jednak, że te ograniczenia nie miały podczas nich znaczenia.


\begin{qxtab}{edgeenum}{Użyte wersje baz danych}
\begin{tabular}{l|l|l}
Baza danych                            & Wersja & Edycja \\
\hline
PostgreSQL\index{PostgreSQL}           &  8.4      & \\
MySQL\index{MySQL}                     &  5.1      & \\
SQLite\index{SQLite}                   &  3        & \\
Oracle Database\index{Oracle}          &  10g      & Express Edition \\
IBM DB2\index{IBM DB2}                 &  9.7      & Express-C \\
Microsoft SQL Server\index{SQL Server} &  2008 R2  & Express\\
\end{tabular}
\end{qxtab}

\todo{Napisać jaki typ tabelek został użyty w MySQL (MyISAM, InnoDB)}

\subsection*{Dane testowe}

By móc porównać metody przechowywania danych hierarchicznych należy zapewnić jednorodne warunki testów.
Oznacza to konieczność wykonywania dokładnie tych samych operacji, z takimi samymi parametrami, w tej samej kolejności.
Aby to osiągnąć testy są przechowywane wewnątrz plików XML (w podkatalogu \verb|src/data|).

Dane użyte podczas zaprezentowanych testów zostały wygenerowane w sposób automatyczny.
Opisują one las o wysokości $10$, zawierający dwa drzewa, 
z każdym węzłem wewnętrznym o stopniu $2$.
W efekcie całe drzewo ma $4094$ węzły.

\subsection*{Środowisko testowe}

Bazy danych były testowane na systemie operacyjnym \emph{Microsoft Windows 7 32bit}.
Wybór ten był podyktowany faktem, że jedna z testowanych baz (SQL Server) posiadała wersję wyłącznie na systemy z rodziny Windows.

Sprzęt, na którym wykonywane były testy, składał się z:
\begin{itemize}
  \item procesora Intel Core2 Quad 2.4 Ghz
  \item 4 GB pamięci DDR2 (3,25 GB pamięci dostępnej dla systemu)
  \item dysku HDD 1TB klasy ekonomicznej
\end{itemize}

Serwer bazy danych działał na tej samej maszynie co program testujący.
Zmniejsza to opóźnienia sieciowe, ale zwiększa zużycie procesora%
\footnote{W praktyce na maszynie czterordzeniowej czas procesora nie był problemem.}.

\subsection*{Optymalizacje}

Aby nie faworyzować żadnej z testowanych baz ustanowione zostały poniższe zasady:
\begin{itemize}
    \item Bazy nie były w żaden sposób dostrajane \eng{database tuning}, czyli pracują z domyślnymi ustawieniami.
    \item Nie zastosowano indeksów\footnote{Jawnych indeksów --- klucze główne były stosowane}
        oraz kluczy obcych.
    \item Zapytania były pisane z myślą by być czytelne i dobrze ilustrować koncepcje danej reprezentacji.
    Została więc zastosowana maksyma Donalda Knutha: \emph{,,przedwczesna optymalizacja jest źródłem wszelkiego zła''}.
\end{itemize}

\subsection*{Prezentacja wyników}

Wyniki wydajności są prezentowane na końcu opisu każdej z opisywanych metod.
Są podawane zarówno w postaci tabeli (umożliwiającej dokładną analizę wyników)
jak i wykresu słupkowego (dającego możliwość szybkiego przejrzenia wyników).

Zastosowaną miarą wydajności jest \emph{przepustowość} (czyli ilość wykonanych zapytań w danym czasie).
Takie podejście jest intuicyjne dla ludzi --- większa wartość oznacza lepszy wynik. 



